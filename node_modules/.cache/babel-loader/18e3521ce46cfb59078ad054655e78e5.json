{"remainingRequest":"/Volumes/MAC1/javaproject/eladmin-web/node_modules/babel-loader/lib/index.js!/Volumes/MAC1/javaproject/eladmin-web/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Volumes/MAC1/javaproject/eladmin-web/node_modules/vue-loader/lib/index.js??vue-loader-options!/Volumes/MAC1/javaproject/eladmin-web/node_modules/vue-echarts/components/ECharts.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Volumes/MAC1/javaproject/eladmin-web/node_modules/vue-echarts/components/ECharts.vue","mtime":499162500000},{"path":"/Volumes/MAC1/javaproject/eladmin-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Volumes/MAC1/javaproject/eladmin-web/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Volumes/MAC1/javaproject/eladmin-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Volumes/MAC1/javaproject/eladmin-web/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\n\nvar _interopRequireDefault = require(\"/Volumes/MAC1/javaproject/eladmin-web/node_modules/@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nrequire(\"core-js/modules/es6.object.keys\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.function.name\");\n\nvar _echarts = _interopRequireDefault(require(\"echarts/lib/echarts\"));\n\nvar _debounce = _interopRequireDefault(require(\"lodash/debounce\"));\n\nvar _resizeDetector = require(\"resize-detector\");\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nvar INIT_TRIGGERS = ['theme', 'initOptions', 'autoresize'];\nvar REWATCH_TRIGGERS = ['manualUpdate', 'watchShallow'];\nvar _default = {\n  props: {\n    options: Object,\n    theme: [String, Object],\n    initOptions: Object,\n    group: String,\n    autoresize: Boolean,\n    watchShallow: Boolean,\n    manualUpdate: Boolean\n  },\n  data: function data() {\n    return {\n      lastArea: 0\n    };\n  },\n  watch: {\n    group: function group(_group) {\n      this.chart.group = _group;\n    }\n  },\n  methods: {\n    // provide an explicit merge option method\n    mergeOptions: function mergeOptions(options, notMerge, lazyUpdate) {\n      if (this.manualUpdate) {\n        this.manualOptions = options;\n      }\n\n      if (!this.chart) {\n        this.init(options);\n      } else {\n        this.delegateMethod('setOption', options, notMerge, lazyUpdate);\n      }\n    },\n    // just delegates ECharts methods to Vue component\n    // use explicit params to reduce transpiled size for now\n    appendData: function appendData(params) {\n      this.delegateMethod('appendData', params);\n    },\n    resize: function resize(options) {\n      this.delegateMethod('resize', options);\n    },\n    dispatchAction: function dispatchAction(payload) {\n      this.delegateMethod('dispatchAction', payload);\n    },\n    convertToPixel: function convertToPixel(finder, value) {\n      return this.delegateMethod('convertToPixel', finder, value);\n    },\n    convertFromPixel: function convertFromPixel(finder, value) {\n      return this.delegateMethod('convertFromPixel', finder, value);\n    },\n    containPixel: function containPixel(finder, value) {\n      return this.delegateMethod('containPixel', finder, value);\n    },\n    showLoading: function showLoading(type, options) {\n      this.delegateMethod('showLoading', type, options);\n    },\n    hideLoading: function hideLoading() {\n      this.delegateMethod('hideLoading');\n    },\n    getDataURL: function getDataURL(options) {\n      return this.delegateMethod('getDataURL', options);\n    },\n    getConnectedDataURL: function getConnectedDataURL(options) {\n      return this.delegateMethod('getConnectedDataURL', options);\n    },\n    clear: function clear() {\n      this.delegateMethod('clear');\n    },\n    dispose: function dispose() {\n      this.delegateMethod('dispose');\n    },\n    delegateMethod: function delegateMethod(name) {\n      var _this$chart;\n\n      if (!this.chart) {\n        this.init();\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return (_this$chart = this.chart)[name].apply(_this$chart, args);\n    },\n    delegateGet: function delegateGet(methodName) {\n      if (!this.chart) {\n        this.init();\n      }\n\n      return this.chart[methodName]();\n    },\n    getArea: function getArea() {\n      return this.$el.offsetWidth * this.$el.offsetHeight;\n    },\n    init: function init(options) {\n      var _this = this;\n\n      if (this.chart) {\n        return;\n      }\n\n      var chart = _echarts.default.init(this.$el, this.theme, this.initOptions);\n\n      if (this.group) {\n        chart.group = this.group;\n      }\n\n      chart.setOption(options || this.manualOptions || this.options || {}, true);\n      Object.keys(this.$listeners).forEach(function (event) {\n        var handler = _this.$listeners[event];\n\n        if (event.indexOf('zr:') === 0) {\n          chart.getZr().on(event.slice(3), handler);\n        } else {\n          chart.on(event, handler);\n        }\n      });\n\n      if (this.autoresize) {\n        this.lastArea = this.getArea();\n        this.__resizeHandler = (0, _debounce.default)(function () {\n          if (_this.lastArea === 0) {\n            // emulate initial render for initially hidden charts\n            _this.mergeOptions({}, true);\n\n            _this.resize();\n\n            _this.mergeOptions(_this.options || _this.manualOptions || {}, true);\n          } else {\n            _this.resize();\n          }\n\n          _this.lastArea = _this.getArea();\n        }, 100, {\n          leading: true\n        });\n        (0, _resizeDetector.addListener)(this.$el, this.__resizeHandler);\n      }\n\n      Object.defineProperties(this, {\n        // Only recalculated when accessed from JavaScript.\n        // Won't update DOM on value change because getters\n        // don't depend on reactive values\n        width: {\n          configurable: true,\n          get: function get() {\n            return _this.delegateGet('getWidth');\n          }\n        },\n        height: {\n          configurable: true,\n          get: function get() {\n            return _this.delegateGet('getHeight');\n          }\n        },\n        isDisposed: {\n          configurable: true,\n          get: function get() {\n            return !!_this.delegateGet('isDisposed');\n          }\n        },\n        computedOptions: {\n          configurable: true,\n          get: function get() {\n            return _this.delegateGet('getOption');\n          }\n        }\n      });\n      this.chart = chart;\n    },\n    initOptionsWatcher: function initOptionsWatcher() {\n      var _this2 = this;\n\n      if (this.__unwatchOptions) {\n        this.__unwatchOptions();\n\n        this.__unwatchOptions = null;\n      }\n\n      if (!this.manualUpdate) {\n        this.__unwatchOptions = this.$watch('options', function (val, oldVal) {\n          if (!_this2.chart && val) {\n            _this2.init();\n          } else {\n            // mutating `options` will lead to merging\n            // replacing it with new reference will lead to not merging\n            // eg.\n            // `this.options = Object.assign({}, this.options, { ... })`\n            // will trigger `this.chart.setOption(val, true)\n            // `this.options.title.text = 'Trends'`\n            // will trigger `this.chart.setOption(val, false)`\n            _this2.chart.setOption(val, val !== oldVal);\n          }\n        }, {\n          deep: !this.watchShallow\n        });\n      }\n    },\n    destroy: function destroy() {\n      if (this.autoresize) {\n        (0, _resizeDetector.removeListener)(this.$el, this.__resizeHandler);\n      }\n\n      this.dispose();\n      this.chart = null;\n    },\n    refresh: function refresh() {\n      if (this.chart) {\n        this.destroy();\n        this.init();\n      }\n    }\n  },\n  created: function created() {\n    var _this3 = this;\n\n    this.initOptionsWatcher();\n    INIT_TRIGGERS.forEach(function (prop) {\n      _this3.$watch(prop, function () {\n        _this3.refresh();\n      }, {\n        deep: true\n      });\n    });\n    REWATCH_TRIGGERS.forEach(function (prop) {\n      _this3.$watch(prop, function () {\n        _this3.initOptionsWatcher();\n\n        _this3.refresh();\n      });\n    });\n  },\n  mounted: function mounted() {\n    // auto init if `options` is already provided\n    if (this.options) {\n      this.init();\n    }\n  },\n  activated: function activated() {\n    if (this.autoresize) {\n      this.chart && this.chart.resize();\n    }\n  },\n  destroyed: function destroyed() {\n    if (this.chart) {\n      this.destroy();\n    }\n  },\n  connect: function connect(group) {\n    if (typeof group !== 'string') {\n      group = group.map(function (chart) {\n        return chart.chart;\n      });\n    }\n\n    _echarts.default.connect(group);\n  },\n  disconnect: function disconnect(group) {\n    _echarts.default.disConnect(group);\n  },\n  registerMap: function registerMap(mapName, geoJSON, specialAreas) {\n    _echarts.default.registerMap(mapName, geoJSON, specialAreas);\n  },\n  registerTheme: function registerTheme(name, theme) {\n    _echarts.default.registerTheme(name, theme);\n  },\n  graphic: _echarts.default.graphic\n};\nexports.default = _default;",null]}